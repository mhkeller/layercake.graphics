{"main":{"title":"index.svelte","contents":"<script>\n  import SyncedBrushWrapper from './components/SyncedBrushWrapper.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import pointsOne from './data/points.csv';\n  import pointsTwo from './data/pointsTwo.csv';\n  import pointsThree from './data/pointsThree.csv';\n  import pointsFour from './data/pointsFour.csv';\n\n  let brushExtents = [null, null];\n\n  const xKey = 'myX';\n  const yKey = 'myY';\n\n  const datasets = [\n    pointsOne,\n    pointsTwo,\n    pointsThree,\n    pointsFour\n  ];\n\n  datasets.forEach(dataset => {\n    dataset.forEach(d => {\n      d[yKey] = +d[yKey];\n    });\n  });\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .small-multiple-container {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    align-content: space-between;\n  }\n</style>\n\n<div class=\"small-multiple-container\">\n  {#each datasets as dataset}\n    <SyncedBrushWrapper\n      data={dataset}\n      {xKey}\n      {yKey}\n      bind:min={brushExtents[0]}\n      bind:max={brushExtents[1]}\n    />\n  {/each}\n</div>"},"dek":"","components":[{"title":"./components/SyncedBrushWrapper.svelte","contents":"<script>\n  import { LayerCake, Svg, Html } from 'layercake';\n\n  import Line from './Line.svelte';\n  import Area from './Area.svelte';\n  import AxisX from './AxisX.svelte';\n  import AxisY from './AxisY.svelte';\n  import Brush from './Brush.html.svelte';\n\n  export let min = null;\n  export let max = null;\n  export let xKey = 'x';\n  export let yKey = 'y';\n  export let data = [];\n\n  let brushedData;\n  $: {\n    brushedData = data.slice((min || 0) * data.length, (max || 1) * data.length);\n    if (brushedData.length < 2) {\n      brushedData = data.slice(min * data.length, min * data.length + 2)\n    }\n  }\n</script>\n\n<style>\n  .chart-wrapper {\n    width: 48%;\n    height: 48%;\n  }\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 80%;\n  }\n  .brush-container {\n    width: 100%;\n    height: 20%;\n  }\n</style>\n\n<div class=\"chart-wrapper\">\n  <div class=\"chart-container\">\n    <LayerCake\n      padding={{ right: 10, bottom: 20, left: 25 }}\n      x={xKey}\n      y={yKey}\n      yDomain={[0, null]}\n      data={brushedData}\n    >\n      <Svg>\n        <AxisX\n          ticks={ticks => {\n            const filtered = ticks.filter(t => t % 1 === 0);\n            if (filtered.length > 7) {\n              return filtered.filter((t, i) => i % 2 === 0);\n            }\n            return filtered;\n          }}\n        />\n        <AxisY\n          ticks={2}\n        />\n        <Line\n          stroke='#00e047'\n        />\n        <Area\n          fill='#00e04710'\n        />\n      </Svg>\n    </LayerCake>\n  </div>\n\n  <div class=\"brush-container\">\n    <LayerCake\n      padding={{ top: 5 }}\n      x={xKey}\n      y={yKey}\n      yDomain={[0, null]}\n      data={data}\n    >\n      <Svg>\n        <Line\n          stroke='#00e047'\n        />\n        <Area\n          fill='#00e04710'\n        />\n      </Svg>\n      <Html>\n        <Brush\n          bind:min={min}\n          bind:max={max}\n        />\n      </Html>\n    </LayerCake>\n  </div>\n</div>"}],"modules":[],"componentModules":[],"componentComponents":[{"title":"./components/Line.svelte","contents":"<script>\n  /**\n    Generates an SVG area shape using the `area` function from [d3-shape](https://github.com/d3/d3-shape).\n    @param {String} [stroke='#ab00d6'] – The shape's fill color. This is technically optional because it comes with a default value but you'll likely want to replace it with your own color.\n  */\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet } = getContext('LayerCake');\n\n  export let stroke = '#ab00d6';\n\n  $: path = 'M' + $data\n    .map(d => {\n      return $xGet(d) + ',' + $yGet(d);\n    })\n    .join('L');\n</script>\n\n<path class='path-line' d='{path}' {stroke}></path>\n\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 2;\n  }\n</style>"},{"title":"./components/Area.svelte","contents":"<script>\n  /**\n    Generates an SVG area shape manually constructing the SVG path.\n    @param {String} [fill='#ab00d610'] – The shape's fill color. This is technically optional because it comes with a default value but you'll likely want to replace it with your own color.\n  */\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, xScale, yScale, extents } = getContext('LayerCake');\n\n  export let fill = '#ab00d610';\n\n  $: path = 'M' + $data\n    .map(d => {\n      return $xGet(d) + ',' + $yGet(d);\n    })\n    .join('L');\n\n  let area;\n\n  $: {\n    const yRange = $yScale.range();\n    area = path + (\n      'L' + $xScale($extents.x ? $extents.x[1] : 0) + ',' + yRange[0] +\n      'L' + $xScale($extents.x ? $extents.x[0] : 0) + ',' + yRange[0] +\n      'Z'\n    );\n  }\n</script>\n\n<path class='path-area' d='{area}' {fill}></path>"},{"title":"./components/AxisX.svelte","contents":"<script>\n  /**\n    Generates an SVG x-axis. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n    @param {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space\n    @param {Boolean} [tickMarks=false] – Show a vertical mark for each tick.\n    @param {Boolean} [baseline=false] – Show a solid line at the bottom.\n    @param {Boolean} [snapTicks=false] – Instead of centering the text on the first and the last items, align them to the edges of the chart.\n    @param {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return.\n    @param {Number|Array|Function} [ticks] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function.\n    @param {Number} [xTick=0] – TK\n    @param {Number} [yTick=16] – The distance from the baseline to place each tick value.\n  */\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yRange } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let tickMarks = false;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let formatTick = d => d;\n  export let ticks = undefined;\n  export let xTick = 0;\n  export let yTick = 16;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class='axis x-axis' class:snapTicks>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{ i }' transform='translate({$xScale(tick)},{$yRange[0]})'>\n      {#if gridlines !== false}\n        <line class=\"gridline\" y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      {#if tickMarks === true}\n        <line class=\"tick-mark\" y1='{0}' y2='{6}' x1='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}' x2='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}'></line>\n      {/if}\n      <text\n        x=\"{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}\"\n        y='{yTick}'\n        dx=''\n        dy=''\n        text-anchor='{textAnchor(i)}'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick .tick-mark,\n  .baseline {\n    stroke-dasharray: 0;\n  }\n  /* This looks slightly better */\n  .axis.snapTicks .tick:last-child text {\n    transform: translateX(3px);\n  }\n  .axis.snapTicks .tick.tick-0 text {\n    transform: translateX(-3px);\n  }\n</style>"},{"title":"./components/AxisY.svelte","contents":"<script>\n  /**\n    Generates an HTML y-axis.\n    @param {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space\n    @param {Boolean} [tickMarks=false] – Show a vertical mark for each tick.\n    @param {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return.\n    @param {Number|Array|Function} [ticks=4] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return.\n    @param {Number} [xTick=0] – How far over to position the text marker.\n    @param {Number} [dxTick=0] – Any optional value passed to the `dx` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal.\n    @param {Number} [yTick=0] – How far up and down to position the text marker.\n    @param {Number} [dyTick=0] – Any optional value passed to the `dy` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal.\n  */\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, yScale } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let tickMarks = false;\n  export let formatTick = d => d;\n  export let ticks = 4;\n  export let xTick = 0;\n  export let yTick = 0;\n  export let dxTick = 0;\n  export let dyTick = -4;\n  export let textAnchor = 'start';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<g class='axis y-axis' transform='translate({-$padding.left}, 0)'>\n  {#each tickVals as tick}\n    <g class='tick tick-{tick}' transform='translate({$xRange[0] + (isBandwidth ? $padding.left : 0)}, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line\n          class=\"gridline\"\n          x2='100%'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      {#if tickMarks === true}\n        <line\n          class='tick-mark'\n          x1='0'\n          x2='{isBandwidth ? -6 : 6}'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      <text\n        x='{xTick}'\n        y='{yTick + (isBandwidth ? $yScale.bandwidth() / 2 : 0)}'\n        dx='{isBandwidth ? -9 : dxTick}'\n        dy='{isBandwidth ? 4 : dyTick}'\n        style=\"text-anchor:{isBandwidth ? 'end' : textAnchor};\"\n      >{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n  }\n  .tick .gridline {\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/Brush.html.svelte","contents":"<script>\n  /**\n    Adds a brush component to create a range between 0 and 1. Bind to the `min` and `max` props to use them in other components. See the [brushable example](https://layercake.graphcics/example/Brush) for use.\n    @param {Number} min – The brush's min value.\n    @param {Number} max – The brush's max value.\n  */\n  import { clamp } from 'yootils';\n\n  export let min;\n  export let max;\n\n  let brush;\n\n  const p = x => {\n    const { left, right } = brush.getBoundingClientRect();\n    return clamp((x - left) / (right - left), 0, 1);\n  };\n\n  const handler = fn => {\n    return e => {\n      if (e.type === 'touchstart') {\n        if (e.touches.length !== 1) return;\n        e = e.touches[0];\n      }\n\n      const id = e.identifier;\n      const start = { min, max, p: p(e.clientX) };\n\n      const handle_move = e => {\n        if (e.type === 'touchmove') {\n          if (e.changedTouches.length !== 1) return;\n          e = e.changedTouches[0];\n          if (e.identifier !== id) return;\n        }\n\n        fn(start, p(e.clientX));\n      };\n\n      const handle_end = e => {\n        if (e.type === 'touchend') {\n          if (e.changedTouches.length !== 1) return;\n          if (e.changedTouches[0].identifier !== id) return;\n        } else if (e.target === brush) {\n          clear();\n        }\n\n        window.removeEventListener('mousemove', handle_move);\n        window.removeEventListener('mouseup', handle_end);\n\n        window.removeEventListener('touchmove', handle_move);\n        window.removeEventListener('touchend', handle_end);\n      };\n\n      window.addEventListener('mousemove', handle_move);\n      window.addEventListener('mouseup', handle_end);\n\n      window.addEventListener('touchmove', handle_move);\n      window.addEventListener('touchend', handle_end);\n    };\n  };\n\n  const clear = () => {\n    min = null;\n    max = null;\n  }\n\n  const reset = handler((start, p) => {\n    min = clamp(Math.min(start.p, p), 0, 1);\n    max = clamp(Math.max(start.p, p), 0, 1);\n  });\n\n  const move = handler((start, p) => {\n    const d = clamp(p - start.p, -start.min, 1 - start.max);\n    min = start.min + d;\n    max = start.max + d;\n  });\n\n  const adjust_min = handler((start, p) => {\n    min = p > start.max ? start.max : p;\n    max = p > start.max ? p : start.max;\n  });\n\n  const adjust_max = handler((start, p) => {\n    min = p < start.min ? p : start.min;\n    max = p < start.min ? start.min : p;\n  });\n\n  $: left = 100 * min;\n  $: right = 100 * (1 - max);\n</script>\n\n<div bind:this={brush} class=\"brush-outer\" on:mousedown|stopPropagation={reset} on:touchstart|stopPropagation={reset}>\n  {#if min !== null}\n    <div class=\"brush-inner\" on:mousedown|stopPropagation={move} on:touchstart|stopPropagation={move} style=\"left: {left}%; right: {right}%\"></div>\n    <div class=\"brush-handle\" on:mousedown|stopPropagation={adjust_min} on:touchstart|stopPropagation={adjust_min} style=\"left: {left}%\"></div>\n    <div class=\"brush-handle\" on:mousedown|stopPropagation={adjust_max} on:touchstart|stopPropagation={adjust_max} style=\"right: {right}%\"></div>\n  {/if}\n</div>\n\n<style>\n  .brush-outer {\n    position: relative;\n    width: 100%;\n    height: calc(100% + 5px);\n    top: -5px;\n  }\n\n  .brush-inner {\n    position: absolute;\n    height: 100%;\n    cursor: move;\n    /* mix-blend-mode: difference; */\n    background-color: #cccccc90;\n    /* border: 1px solid #000; */\n  }\n\n  .brush-handle {\n    position: absolute;\n    width: 0;\n    height: 100%;\n    cursor: ew-resize;\n  }\n\n  .brush-handle::before {\n    position: absolute;\n    content: '';\n    width: 8px;\n    left: -4px;\n    height: 100%;\n    background: transparent;\n  }\n</style>"}],"csvs":[{"title":"./data/points.csv","contents":"myX,myY\n1979,7.19\n1980,7.83\n1981,7.24\n1982,7.44\n1983,7.51\n1984,7.1\n1985,6.91\n1986,7.53\n1987,7.47\n1988,7.48\n1989,7.03\n1990,6.23\n1991,6.54\n1992,7.54\n1993,6.5\n1994,7.18\n1995,6.12\n1996,7.87\n1997,6.73\n1998,6.55\n1999,6.23\n2000,6.31\n2001,6.74\n2002,5.95\n2003,6.13\n2004,6.04\n2005,5.56\n2006,5.91\n2007,4.29\n2008,4.72\n2009,5.38\n2010,4.92\n2011,4.61\n2012,3.62\n2013,5.35\n2014,5.28\n2015,4.63\n2016,4.72"},{"title":"./data/pointsTwo.csv","contents":"myX,myY\n1979,5.03\n1980,3.99\n1981,10.35\n1982,4.06\n1983,10.11\n1984,11.66\n1985,5.95\n1986,7.27\n1987,2.77\n1988,3.43\n1989,6.49\n1990,8.27\n1991,3.85\n1992,6.21\n1993,0.14\n1994,7.65\n1995,5.57\n1996,15.61\n1997,12.42\n1998,5.2\n1999,9.81\n2000,8.64\n2001,10.07\n2002,1.71\n2003,3\n2004,11.82\n2005,4.74\n2006,4.25\n2007,0.16\n2008,7.97\n2009,9.75\n2010,3.34\n2011,3.46\n2012,1.73\n2013,5.97\n2014,2.17\n2015,0.88\n2016,8.19"},{"title":"./data/pointsThree.csv","contents":"myX,myY\n1979,5.43\n1980,7.27\n1981,8.82\n1982,13.14\n1983,14.63\n1984,5.41\n1985,4.76\n1986,12.46\n1987,10.38\n1988,0.06\n1989,9.35\n1990,5.84\n1991,6.94\n1992,2.78\n1993,9.84\n1994,6.48\n1995,9.97\n1996,4.85\n1997,5.35\n1998,4.12\n1999,1.56\n2000,10.11\n2001,2.04\n2002,4.03\n2003,3.85\n2004,8.61\n2005,1.44\n2006,9.41\n2007,3.51\n2008,4.12\n2009,6.76\n2010,3.65\n2011,6.76\n2012,6.46\n2013,0.75\n2014,9.93\n2015,8.11\n2016,1.4"},{"title":"./data/pointsFour.csv","contents":"myX,myY\n1979,10.27\n1980,1.99\n1981,2.25\n1982,3.56\n1983,0.32\n1984,4.18\n1985,1.75\n1986,2.35\n1987,2.54\n1988,6.53\n1989,5.02\n1990,3.4\n1991,4.79\n1992,1.29\n1993,12.65\n1994,5.26\n1995,3.11\n1996,14.92\n1997,13.21\n1998,10.34\n1999,5.02\n2000,9.11\n2001,13.24\n2002,8.02\n2003,1.54\n2004,0.25\n2005,6.02\n2006,5.91\n2007,6.83\n2008,6.76\n2009,3.7\n2010,2.3\n2011,3.37\n2012,4.02\n2013,2.15\n2014,2.33\n2015,5.98\n2016,6.27"}],"jsons":[]}