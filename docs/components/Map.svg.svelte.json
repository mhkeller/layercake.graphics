{"main":{"slug":"Map.svg.svelte","contents":"<script>\n  /**\n    Generates an SVG map using the `geoPath` function from [d3-geo](https://github.com/d3/d3-geo).\n    @type {Function} projection – A D3 projection function. Pass this in as an uncalled function, e.g. `projection={geoAlbersUsa}`.\n    @type {GeoJsonFeatureCollection} [features=$data.features] – A GeoJSON feature collection that has an array of features on its `features` key. Use this if you want to draw a subset of the features in `$data` while keeping the zoom on the whole GeoJSON feature set. By default, it plots everything in `$data`.\n    @type {String} [stroke='#ccc'] – The shape's stroke color.\n    @type {Number} [strokeWidth=1] – The shape's stroke width.\n    @type {String} [fill='#fff'] – The shape's fill color.\n  */\n  import { getContext, createEventDispatcher } from 'svelte';\n  import { geoPath } from 'd3-geo';\n  import { raise } from 'layercake';\n\n  const { data, width, height, zGet } = getContext('LayerCake');\n\n  export let projection;\n  export let fixedAspectRatio = undefined;\n  export let fill = undefined; // The fill will be determined by the scale, unless this prop is set\n  export let stroke = '#333';\n  export let strokeWidth = 0.5;\n  export let features = $data.features;\n\n  /* --------------------------------------------\n   * Here's how you would do cross-component hovers\n   */\n  const dispatch = createEventDispatcher();\n\n  $: fitSizeRange = fixedAspectRatio ? [100, 100 / fixedAspectRatio] : [$width, $height];\n\n  $: projectionFn = projection()\n    .fitSize(fitSizeRange, $data);\n\n  $: geoPathFn = geoPath(projectionFn);\n\n  function handleMousemove(feature) {\n    return function handleMousemoveFn(e) {\n      raise(this);\n      // When the element gets raised, it flashes 0,0 for a second so skip that\n      if (e.layerX !== 0 && e.layerY !== 0) {\n        dispatch('mousemove', { e, props: feature.properties });\n      }\n    }\n  }\n</script>\n\n<g\n  class=\"map-group\"\n  on:mouseout={(e) => dispatch('mouseout')}\n>\n  {#each features as feature}\n    <path\n      class=\"feature-path\"\n      fill=\"{fill || $zGet(feature.properties)}\"\n      stroke={stroke}\n      stroke-width={strokeWidth}\n      d=\"{geoPathFn(feature)}\"\n      on:mouseover={(e) => dispatch('mousemove', { e, props: feature.properties })}\n      on:mousemove={handleMousemove(feature)}\n    ></path>\n  {/each}\n</g>\n\n<style>\n  /* .feature-path {\n    stroke: #333;\n    stroke-width: 0.5px;\n  } */\n  .feature-path:hover {\n    stroke: #000;\n    stroke-width: 2px;\n  }\n</style>"},"dek":"","usedIn":[{"group":"Regular","matches":["/example/MapLayered","/example/MapSvg"]},{"group":"SSR","matches":["/example-ssr/MapLayered","/example-ssr/MapSvg"]}],"jsdocParsed":{"description":"Generates an SVG map using the `geoPath` function from [d3-geo](https://github.com/d3/d3-geo).","tags":[{"title":"param","description":"– A D3 projection function. Pass this in as an uncalled function, e.g. `projection={geoAlbersUsa}`.","type":{"type":"NameExpression","name":"Function"},"name":"projection"},{"title":"param","description":"– A GeoJSON feature collection that has an array of features on its `features` key. Use this if you want to draw a subset of the features in `$data` while keeping the zoom on the whole GeoJSON feature set. By default, it plots everything in `$data`.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"GeoJsonFeatureCollection"}},"name":"features","default":"$data.features"},{"title":"param","description":"– The shape's stroke color.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"String"}},"name":"stroke","default":"'#ccc'"},{"title":"param","description":"– The shape's stroke width.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"Number"}},"name":"strokeWidth","default":"1"},{"title":"param","description":"– The shape's fill color.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"String"}},"name":"fill","default":"'#fff'"}]}}