{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, Svg, WebGL, Html } from 'layercake';\n  import points from './data/points.csv';\n  import ScatterWebGL from './components/ScatterWebGL.svelte';\n  import AxisX from './components/AxisX.svelte';\n  import AxisY from './components/AxisY.svelte';\n  import QuadTree from './components/QuadTree.svelte';\n\n  const diameter = 6;\n  const padding = 6;\n\n  points.forEach(row => {\n    row.myY = +row.myY;\n  });\n</script>\n\n<style>\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n\n  .circle {\n    position: absolute;\n    border-radius: 50%;\n    background-color: rgba(171,0, 214);\n    transform: translate(-50%, -50%);\n    pointer-events: none;\n    width: 10px;\n    height: 10px;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 0, right: 5, bottom: 20, left: 25 }}\n    x={'myX'}\n    y={'myY'}\n    xPadding={[padding, padding]}\n    yPadding={[padding, padding]}\n    data={points}\n  >\n    <Svg>\n      <AxisX/>\n      <AxisY/>\n    </Svg>\n\n    <WebGL>\n      <ScatterWebGL {diameter}/>\n    </WebGL>\n\n    <Html>\n      <QuadTree\n        let:x\n        let:y\n        let:visible\n      >\n        <div\n          class=\"circle\"\n          style=\"top:{y}px;left:{x}px;display: { visible ? 'block' : 'none' };\"\n        ></div>\n      </QuadTree>\n    </Html>\n  </LayerCake>\n</div>"},"dek":"","components":[{"title":"./components/ScatterWebGL.svelte","contents":"<script>\n  import reglWrapper from 'regl';\n  import { getContext } from 'svelte';\n  import { scaleCanvas } from 'layercake';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  export let diameter;\n\n  const { gl } = getContext('gl');\n\n  function resize () {\n    if ($gl) {\n      const canvas = $gl.canvas;\n      // Lookup the size the browser is displaying the canvas.\n      const displayWidth = canvas.clientWidth;\n      const displayHeight = canvas.clientHeight;\n\n      // Check if the canvas is not the same size.\n      if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n        // Make the canvas the same size\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n      }\n      $gl.viewport(0, 0, canvas.width, canvas.height);\n    }\n  }\n\n  let regl;\n\n  function render () {\n    if ($gl) {\n      regl = reglWrapper({\n        gl: $gl,\n        extensions: ['oes_standard_derivatives']\n      });\n\n      // console.log('rendering', regl);\n      regl.clear({\n        color: [0, 0, 0, 0],\n        depth: 1\n      });\n\n      const draw = regl({\n        // circle code comes from:\n        // https://www.desultoryquest.com/blog/drawing-anti-aliased-circular-points-using-opengl-slash-webgl/\n        frag: `\n        #extension GL_OES_standard_derivatives : enable\n        precision mediump float;\n        uniform vec3 fill_color;\n        uniform vec3 stroke_color;\n        varying float s_s;\n        void main () {\n\n          vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\n          float dist = dot(cxy, cxy);\n\n          float delta = fwidth(dist);\n\n          float alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, dist);\n\n          float outer_edge_center = 1.0 - s_s;\n          float stroke = 1.0 - smoothstep(outer_edge_center - delta, outer_edge_center + delta, dist);\n\n          // gl_FragColor = vec4(fill_color,1.0) * alpha;\n          gl_FragColor = vec4( mix(stroke_color, fill_color, stroke), 1.0 ) * alpha;\n          gl_FragColor.rgb *= gl_FragColor.a;\n        }`,\n        vert: `\n        precision mediump float;\n        attribute vec2 position;\n        attribute float r;\n        attribute float stroke_size;\n\n        varying float s_s;\n\n        uniform float stage_width;\n        uniform float stage_height;\n\n        // http://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html\n        vec2 normalizeCoords(vec2 position) {\n          // read in the positions into x and y vars\n          float x = position[0];\n          float y = position[1];\n          return vec2(\n            2.0 * ((x / stage_width) - 0.5),\n            // invert y to treat [0,0] as bottom left in pixel space\n            -(2.0 * ((y / stage_height) - 0.5))\n          );\n        }\n\n        void main () {\n          s_s = stroke_size;\n          gl_PointSize = r;\n          gl_Position = vec4(normalizeCoords(position), 0.0, 1.0);\n        }`,\n        attributes: {\n          // There will be a position value for each point\n          // we pass in\n          position: (context, props) => {\n            return props.points.map(point => {\n              return [$xGet(point), $yGet(point)];\n            });\n          },\n          r: (context, props) => {\n            // const m = window.devicePixelRatio > 1 ? 4.0 : 2.0\n            // If using an r-scale, set width here\n            return props.points.map(point => props.pointWidth);\n          },\n          stroke_size: (context, props) => {\n            // If using an r-scale, set width here\n            return props.points.map(point => 0);\n          }\n        },\n        uniforms: {\n          fill_color: [0.6705882352941176, 0, 0.8392156862745098],\n          // stroke_color: [0.6705882352941176, 0, 0.8392156862745098],\n          stroke_color: [0, 0, 0],\n          // FYI: there is a helper method for grabbing\n          // values out of the context as well.\n          // These uniforms are used in our fragment shader to\n          // convert our x / y values to WebGL coordinate space.\n          stage_width: regl.context('drawingBufferWidth'),\n          stage_height: regl.context('drawingBufferHeight')\n        },\n        count: (context, props) => {\n          // set the count based on the number of points we have\n          return props.points.length;\n        },\n        primitive: 'points',\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: 'src alpha',\n            srcAlpha: 'src alpha',\n            dstRGB: 'one minus src alpha',\n            dstAlpha: 'one minus src alpha'\n          }\n        },\n        depth: { enable: false }\n      });\n\n      draw({\n        pointWidth: diameter,\n        points: $data\n      });\n    }\n  }\n\n  $: ($width, $height, $gl, resize(), render());\n\n</script>"},{"title":"./components/AxisX.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yScale } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let formatTick = d => d;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let ticks = undefined;\n  export let tickNumber = undefined;\n\n  $: tickVals = ticks || $xScale.ticks(tickNumber);\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'end';\n      }\n      if (i === tickVals.length - 1) {\n        return 'start';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class='axis x-axis'>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yScale.range()[0]})'>\n      {#if gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text y='16' text-anchor='{textAnchor(i)}'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .baseline {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/AxisY.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { padding, yScale } = getContext('LayerCake');\n\n  export let ticks = undefined;\n  export let tickNumber = 5;\n  export let gridlines = true;\n  export let formatTick = d => d;\n\n</script>\n\n<g class='axis y-axis' transform='translate(-{$padding.left}, 0)'>\n  {#each $yScale.ticks(ticks || tickNumber) as tick, i}\n    <g class='tick tick-{tick}' transform='translate(0, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line x2='100%'></line>\n      {/if}\n      <text y='-4'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n    text-anchor: start;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/QuadTree.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n  import { quadtree } from 'd3-quadtree';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  let visible = false;\n  let found = {};\n  let e = {};\n\n  export let dataset = undefined;\n  export let x = 'x';\n  export let y = 'y';\n\n  $: xGetter = x === 'x' ? $xGet : $yGet;\n  $: yGetter = y === 'y' ? $yGet : $xGet;\n\n  function findItem (evt) {\n    e = evt;\n    found = finder.find(evt[`layer${x.toUpperCase()}`], evt[`layer${y.toUpperCase()}`], 300) || {};\n    visible = Object.keys(found).length > 0;\n  }\n\n  $: finder = quadtree()\n    .extent([[-1, -1], [$width + 1, $height + 1]])\n    .x(xGetter)\n    .y(yGetter)\n    .addAll(dataset || $data);\n\n</script>\n\n<style>\n  .bg {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n</style>\n\n<div\n  class=\"bg\"\n  on:mousemove=\"{findItem}\"\n  on:mouseout=\"{() => visible = false}\"\n></div>\n<slot\n  x={xGetter(found) || 0}\n  y={yGetter(found) || 0}\n  {found}\n  {visible}\n  {e}\n></slot>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./data/points.csv","contents":"myX,myY\n1979,7.19\n1980,7.83\n1981,7.24\n1982,7.44\n1983,7.51\n1984,7.1\n1985,6.91\n1986,7.53\n1987,7.47\n1988,7.48\n1989,7.03\n1990,6.23\n1991,6.54\n1992,7.54\n1993,6.5\n1994,7.18\n1995,6.12\n1996,7.87\n1997,6.73\n1998,6.55\n1999,6.23\n2000,6.31\n2001,6.74\n2002,5.95\n2003,6.13\n2004,6.04\n2005,5.56\n2006,5.91\n2007,4.29\n2008,4.72\n2009,5.38\n2010,4.92\n2011,4.61\n2012,3.62\n2013,5.35\n2014,5.28\n2015,4.63\n2016,4.72"}]}