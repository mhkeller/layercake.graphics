{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, Svg, Html } from 'layercake';\n  import { scaleBand } from 'd3-scale';\n\n  import Column from './components/Column.svelte';\n  import AxisX from './components/AxisX.svelte';\n  import AxisY from './components/AxisY.svelte';\n  import Annotations from './components/Annotations.html.svelte';\n  import Arrows from './components/Arrows.svelte';\n  import ArrowheadMarker from './components/ArrowheadMarker.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './data/groups.csv';\n\n  const xKey = 'year';\n  const yKey = 'value';\n\n  const annotations = [\n    {\n      text: 'Example text...',\n      top: '18%',\n      left: '30%',\n      arrows: [{\n        clockwise: false, // true or false, defaults to true\n        source: {\n          anchor: 'left-bottom', // can be `{left, middle, right},{top-middle-bottom}`\n          dx: -2,\n          dy: -7\n        },\n        target: {\n          x: '28%',\n          y: '75%'\n        }\n      },\n      {\n        source: {\n          anchor: 'right-bottom',\n          dy: -7,\n          dx: 5\n        },\n        target: {\n          x: '68%',\n          y: '48%'\n        }\n      }]\n    }\n  ];\n\n  data.forEach(d => {\n    d[yKey] = +d[yKey];\n  });\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 0, right: 0, bottom: 20, left: 20 }}\n    x={xKey}\n    y={yKey}\n    xScale={scaleBand().paddingInner([0.02]).round(true)}\n    xDomain={['1979', '1980', '1981', '1982', '1983']}\n    yDomain={[0, null]}\n    data={data}\n  >\n    <Svg>\n      <Column/>\n      <AxisX\n        gridlines={false}\n      />\n      <AxisY\n        gridlines={false}\n      />\n    </Svg>\n\n    <Html>\n      <Annotations {annotations}/>\n    </Html>\n\n    <Svg>\n      <slot name=\"def\">\n        <ArrowheadMarker/>\n      </slot>\n      <Arrows {annotations}/>\n    </Svg>\n  </LayerCake>\n</div>"},"dek":"Since we want an ordinal x-axis and Layer Cake defaults to a linear scale, pass in a custom scale to `xScale` with a few formatting options. Set the y-scale to always start at `0` so you don't show misleading differences between groups. For the annotation arrowhead, note that, depending on your app structure, such as if you're using Sapper, you may need to provide an [explicit link to your SVG marker id](https://github.com/sveltejs/svelte/issues/3450), such as in `./components/Arrows.svelte` using `window.location.href`.\n","components":[{"title":"./components/Column.svelte","contents":"<script>\n  /**\n    Generates an SVG column chart\n    @type {String} [fill='#00e047'] – The shape's fill color.\n    @type {String} [stroke='#000'] – The shape's stroke color.\n    @type {Number} [strokeWidth=0] – The shape's stroke width.\n  */\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, yRange, xScale } = getContext('LayerCake');\n\n  $: columnWidth = d => {\n    const vals = $xGet(d);\n    return Math.max(0, (vals[1] - vals[0]));\n  };\n\n  $: columnHeight = d => {\n    return $yRange[0] - $yGet(d);\n  };\n\n  /* --------------------------------------------\n   * Default styles\n   */\n  export let fill = '#00e047';\n  export let stroke = '#000';\n  export let strokeWidth = 0;\n\n</script>\n\n<g class=\"column-group\">\n  {#each $data as d, i}\n    <rect\n      class='group-rect'\n      data-id=\"{i}\"\n      x=\"{$xScale.bandwidth ? $xGet(d) : $xGet(d)[0]}\"\n      y=\"{$yGet(d)}\"\n      width=\"{$xScale.bandwidth ? $xScale.bandwidth() : columnWidth(d)}\"\n      height=\"{columnHeight(d)}\"\n      {fill}\n      {stroke}\n      stroke-width=\"{strokeWidth}\"\n    />\n  {/each}\n</g>"},{"title":"./components/AxisX.svelte","contents":"<script>\n  /**\n    Generates an SVG x-axis. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n    @type {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space\n    @type {Boolean} [tickMarks=false] – Show a vertical mark for each tick.\n    @type {Boolean} [baseline=false] – Show a solid line at the bottom.\n    @type {Boolean} [snapTicks=false] – Instead of centering the text on the first and the last items, align them to the edges of the chart.\n    @type {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return.\n    @type {Number|Array|Function} [ticks] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function.\n    @type {Number} [xTick=0] – TK\n    @type {Number} [yTick=16] – The distance from the baseline to place each tick value.\n  */\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yRange } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let tickMarks = false;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let formatTick = d => d;\n  export let ticks = undefined;\n  export let xTick = 0;\n  export let yTick = 16;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class='axis x-axis' class:snapTicks>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{ i }' transform='translate({$xScale(tick)},{$yRange[0]})'>\n      {#if gridlines !== false}\n        <line class=\"gridline\" y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      {#if tickMarks === true}\n        <line class=\"tick-mark\" y1='{0}' y2='{6}' x1='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}' x2='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}'></line>\n      {/if}\n      <text\n        x=\"{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}\"\n        y='{yTick}'\n        dx=''\n        dy=''\n        text-anchor='{textAnchor(i)}'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick .tick-mark,\n  .baseline {\n    stroke-dasharray: 0;\n  }\n  /* This looks slightly better */\n  .axis.snapTicks .tick:last-child text {\n    transform: translateX(3px);\n  }\n  .axis.snapTicks .tick.tick-0 text {\n    transform: translateX(-3px);\n  }\n</style>"},{"title":"./components/AxisY.svelte","contents":"<script>\n  /**\n    Generates an HTML y-axis.\n    @type {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space\n    @type {Boolean} [tickMarks=false] – Show a vertical mark for each tick.\n    @type {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return.\n    @type {Number|Array|Function} [ticks=4] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return.\n    @type {Number} [xTick=0] – How far over to position the text marker.\n    @type {Number} [dxTick=0] – Any optional value passed to the `dx` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal.\n    @type {Number} [yTick=0] – How far up and down to position the text marker.\n    @type {Number} [dyTick=0] – Any optional value passed to the `dy` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal.\n  */\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, yScale } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let tickMarks = false;\n  export let formatTick = d => d;\n  export let ticks = 4;\n  export let xTick = 0;\n  export let yTick = 0;\n  export let dxTick = 0;\n  export let dyTick = -4;\n  export let textAnchor = 'start';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<g class='axis y-axis' transform='translate({-$padding.left}, 0)'>\n  {#each tickVals as tick}\n    <g class='tick tick-{tick}' transform='translate({$xRange[0] + (isBandwidth ? $padding.left : 0)}, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line\n          class=\"gridline\"\n          x2='100%'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      {#if tickMarks === true}\n        <line\n          class='tick-mark'\n          x1='0'\n          x2='{isBandwidth ? -6 : 6}'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      <text\n        x='{xTick}'\n        y='{yTick + (isBandwidth ? $yScale.bandwidth() / 2 : 0)}'\n        dx='{isBandwidth ? -9 : dxTick}'\n        dy='{isBandwidth ? 4 : dyTick}'\n        style=\"text-anchor:{isBandwidth ? 'end' : textAnchor};\"\n      >{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n  }\n  .tick .gridline {\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/Annotations.html.svelte","contents":"<script>\n  /**\n    Adds text annotations based on a config object that has CSS styles as fields.\n    @type {Array} [annotations=[]] – A list of annotation objects. It expects values of `top`, `right`, `bottom` and `left` whose values are CSS values like `'10px'` or `'5%'` that will be used to absolutely position the text div. See the [Column](https://layercake.graphics/example/Column) chart example for the schema and options.\n    @type {Function} [getText=d => d.text] – An accessor function to get the field to display.\n  */\n  const vals = ['top', 'right', 'bottom', 'left'];\n\n  export let annotations = [];\n  export let getText = d => d.text;\n\n  $: fillStyle = d => {\n    let style = '';\n    vals.forEach(val => {\n      if (d[val]) {\n        style += `${val}:${d[val]};`;\n      }\n    });\n    return style;\n  };\n</script>\n\n<div class=\"layercake-annotations\">\n  {#each annotations as d, i}\n    <div\n      class=\"layercake-annotation\"\n      data-id=\"{i}\"\n      style=\"{fillStyle(d)}\"\n    >{getText(d)}</div>\n  {/each}\n</div>\n\n<style>\n  .layercake-annotation {\n    position: absolute;\n  }\n</style>"},{"title":"./components/Arrows.svelte","contents":"<script>\n  /**\n    Adds SVG swoopy arrows based on a config object. It attaches arrows to divs, which are created by another component such as [Annotations.html.svelte](https://layercake.graphics/components/Annotations.html.svelte).\n    @type {Array} [annotations=[]] – A list of annotation objects. See the [Column](https://layercake.graphics/example/Column) chart example for the schema and options.\n    @type {String} [annotationClass='.layercake-annotation'] – The class name of the text annotation divs.\n    @type {String} [containerClass='.chart-container'] – The class name / CSS selector of the parent element of the `<LayerCake>` component. This is used to crawl the DOM for the text annotations.\n  */\n  import { getContext, onMount } from 'svelte';\n\n  import { swoopyArrow, getElPosition, parseCssValue } from '../modules/arrowUtils.js';\n\n  export let annotations = [];\n  export let containerClass = '.chart-container';\n  export let annotationClass = '.layercake-annotation';\n\n  let container;\n\n  // If you're loading this component via sapper or another multi-page app\n  // you will likely need to set an explicit path to the svg marker definition\n  // for Safari compatibility. See https://github.com/sveltejs/svelte/issues/3450\n  // Otherwise, you can remove this variable from here and from the template below\n  $: basePath = typeof window !== 'undefined' ? window.location.href : '';\n\n  const { width, height } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Some lookups to convert between x, y / width, height terminology\n   * and CSS names\n   */\n  const lookups = [\n    { dimension: 'width', css: 'left', position: 'x' },\n    { dimension: 'height', css: 'top', position: 'y' }\n  ];\n\n  let d = () => '';\n  let annotationEls;\n\n  // This searches the DOM for the HTML annotations\n  // in the Annotations.svelte componenent and then\n  // attaches arrows to those divs\n  // Make sure the `.chart-container` and `.layercake-annotation`\n  // selectors match what you have in your project\n  // otherwise it won't find anything\n  onMount(() => {\n    annotationEls = Array.from(\n      container.closest(containerClass)\n        .querySelectorAll(annotationClass)\n    );\n  });\n\n  function setPath (w, h) {\n    return (anno, i, arrow) => {\n      const el = annotationEls[i];\n\n      /* --------------------------------------------\n       * Parse our attachment directives to know where to start the arrowhead\n       * measuring a bounding box based on our annotation el\n       */\n      const arrowSource = getElPosition(el);\n      const sourceCoords = arrow.source.anchor.split('-').map((q, j) => {\n        const point = q === 'middle' ? arrowSource[lookups[j].css] + (arrowSource[lookups[j].dimension] / 2) : arrowSource[q];\n        return point + (parseCssValue(arrow.source[`d${lookups[j].position}`], i, arrowSource.width, arrowSource.height));\n      });\n\n      /* --------------------------------------------\n       * Default to clockwise\n       */\n      const clockwise = typeof arrow.clockwise === 'undefined' ? true : arrow.clockwise;\n\n      /* --------------------------------------------\n       * Parse where we're drawing to\n       */\n      const targetCoords = [arrow.target.x, arrow.target.y].map((q, j) => {\n        return parseCssValue(q, j, w, h);\n      });\n\n      /* --------------------------------------------\n       * Create arrow path\n       */\n      return swoopyArrow()\n        .angle(Math.PI / 2)\n        .clockwise(clockwise)\n        .x(q => q[0])\n        .y(q => q[1])([sourceCoords, targetCoords]);\n    };\n  }\n\n  $: if (annotationEls && annotationEls.length) d = setPath($width, $height);\n</script>\n\n<g bind:this={container}>\n{#if annotations.length}\n  <g class=\"swoops\">\n    {#each annotations as anno, i}\n      {#if anno.arrows}\n        {#each anno.arrows as arrow}\n          <path\n            marker-end='url({ basePath }#arrowhead)'\n            d='{d(anno, i, arrow)}'></path>\n        {/each}\n      {/if}\n    {/each}\n  </g>\n{/if}\n</g>\n\n<style>\n  .swoops {\n    position: absolute;\n    max-width: 200px;\n    line-height: 14px;\n  }\n  .swoops path {\n    fill: none;\n    stroke: #000;\n    stroke-width: 1;\n  }\n</style>"},{"title":"./components/ArrowheadMarker.svelte","contents":"<script>\n  /**\n    Generates an SVG marker containing a marker for a triangle makes a nice arrowhead. Add it to the named slot called \"defs\" on the SVG layout component.\n    @type {fill} [fill='#000'] – The arrowhead's fill color.\n  */\n  export let fill = '#000';\n</script>\n\n<marker id=\"arrowhead\" viewBox=\"-10 -10 20 20\" markerWidth=\"17\" markerHeight=\"17\" orient=\"auto\">\n  <path d=\"M-6,-6 L 0,0 L -6,6\" fill=\"{fill}\"/>\n</marker>"}],"modules":[],"componentModules":[{"title":"./modules/arrowUtils.js","contents":"// Helper functions for creating swoopy arrows\n\n/* --------------------------------------------\n * parseCssValue\n *\n * Parse various inputs and return then as a number\n * Can be a number, which will return the input value\n * A percentage, which will take the percent of the appropriate dimentions\n * A pixel value, which will parse as a number\n *\n */\nexport function parseCssValue(d, i, width, height) {\n  if (!d) return 0;\n  if (typeof d === 'number') {\n    return d;\n  }\n  if (d.indexOf('%') > -1) {\n    return ((+d.replace('%', '')) / 100) * (i ? height : width);\n  }\n  return +d.replace('px', '');\n}\n\n/* --------------------------------------------\n * getElPosition\n *\n * Constract a bounding box relative in our coordinate space\n * that we can attach arrow starting points to\n *\n */\nexport function getElPosition(el) {\n  const annotationBbox = el.getBoundingClientRect();\n  const parentBbox = el.parentNode.getBoundingClientRect();\n  const coords = {\n    top: annotationBbox.top - parentBbox.top,\n    right: annotationBbox.right - parentBbox.left,\n    bottom: annotationBbox.bottom - parentBbox.top,\n    left: annotationBbox.left - parentBbox.left,\n    width: annotationBbox.width,\n    height: annotationBbox.height\n  };\n  return coords;\n}\n\n/* --------------------------------------------\n * swoopyArrow\n *\n * Adapted from bizweekgraphics/swoopyarrows\n *\n */\nexport function swoopyArrow() {\n  let angle = Math.PI;\n  let clockwise = true;\n  let xValue = d => d[0];\n  let yValue = d => d[1];\n\n  function hypotenuse(a, b) {\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  }\n\n  function render(data) {\n    data = data.map((d, i) => {\n      return [xValue.call(data, d, i), yValue.call(data, d, i)];\n    });\n\n    // get the chord length (\"height\" {h}) between points\n    const h = hypotenuse(data[1][0] - data[0][0], data[1][1] - data[0][1]);\n\n    // get the distance at which chord of height h subtends {angle} radians\n    const d = h / (2 * Math.tan(angle / 2));\n\n    // get the radius {r} of the circumscribed circle\n    const r = hypotenuse(d, h / 2);\n\n    /*\n    SECOND, compose the corresponding SVG arc.\n      read up: http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n      example: <path d = \"M 200,50 a 50,50 0 0,1 100,0\"/>\n                          M 200,50                          Moves pen to (200,50);\n                                   a                        draws elliptical arc;\n                                     50,50                  following a degenerate ellipse, r1 == r2 == 50;\n                                                            i.e. a circle of radius 50;\n                                           0                with no x-axis-rotation (irrelevant for circles);\n                                             0,1            with large-axis-flag=0 and sweep-flag=1 (clockwise);\n                                                 100,0      to a point +100 in x and +0 in y, i.e. (300,50).\n    */\n    const path = 'M ' + data[0][0] + ',' + data[0][1] +\n        ' a ' + r + ',' + r +\n        ' 0 0,' + (clockwise ? '1' : '0') + ' ' +\n        (data[1][0] - data[0][0]) + ',' + (data[1][1] - data[0][1]);\n\n    return path;\n  }\n\n  render.angle = function renderAngle (_) {\n    if (!arguments.length) return angle;\n    angle = Math.min(Math.max(_, 1e-6), Math.PI - 1e-6);\n    return render;\n  };\n\n  render.clockwise = function renderClockwise (_) {\n    if (!arguments.length) return clockwise;\n    clockwise = !!_;\n    return render;\n  };\n\n  render.x = function renderX (_) {\n    if (!arguments.length) return xValue;\n    xValue = _;\n    return render;\n  };\n\n  render.y = function renderY (_) {\n    if (!arguments.length) return yValue;\n    yValue = _;\n    return render;\n  };\n\n  return render;\n}"}],"componentComponents":[],"csvs":[{"title":"./data/groups.csv","contents":"year,value\n1979,2\n1980,3\n1981,5\n1982,8\n1983,18"}],"jsons":[]}