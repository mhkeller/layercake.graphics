{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, Svg, Html } from 'layercake';\n  import { scaleOrdinal } from 'd3-scale';\n  import { timeParse, timeFormat } from 'd3-time-format';\n  import { format, precisionFixed } from 'd3-format';\n\n  import MultiLine from './components/MultiLine.svelte';\n  import AxisX from './components/AxisX.svelte';\n  import AxisY from './components/AxisY.svelte';\n  import Labels from './components/GroupLabels.html.svelte';\n  import SharedTooltip from './components/SharedTooltip.html.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './data/fruit.csv';\n\n  /* --------------------------------------------\n   * Set what is our x key to separate it from the other series\n   */\n  const xKey = 'month';\n  const yKey = 'value';\n  const zKey = 'key';\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ffe4b8', '#ffb3c0', '#ff7ac7', '#ff00cc'];\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  const dataLong = seriesNames.map(key => {\n    return {\n      key,\n      values: data.map(d => {\n        d[xKey] = typeof d[xKey] === 'string' ? parseDate(d[xKey]) : d[xKey]; // Conditional required for sapper\n        return {\n          key,\n          [yKey]: +d[key],\n          [xKey]: d[xKey]\n        };\n      })\n    };\n  });\n\n  // Make a flat array of the `values` of our nested series\n  // we can pluck the `value` field from each item in the array to measure extents\n  const flatten = data => data.reduce((memo, group) => {\n    return memo.concat(group.values);\n  }, []);\n\n  const formatTickX = timeFormat('%b. %e');\n  const formatTickY = d => format(`.${precisionFixed(d)}s`)(d);\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 7, right: 10, bottom: 20, left: 25 }}\n    x={xKey}\n    y={yKey}\n    z={zKey}\n    yDomain={[0, null]}\n    zScale={scaleOrdinal()}\n    zDomain={seriesNames}\n    zRange={seriesColors}\n    flatData={flatten(dataLong)}\n    data={dataLong}\n  >\n    <Svg>\n      <AxisX\n        gridlines={false}\n        ticks={data.map(d => d[xKey]).sort((a, b) => a - b)}\n        formatTick={formatTickX}\n        snapTicks={true}\n        tickMarks={true}\n      />\n      <AxisY\n        ticks={4}\n        formatTick={formatTickY}\n      />\n      <MultiLine/>\n    </Svg>\n\n    <Html>\n      <Labels/>\n      <SharedTooltip\n        formatTitle={formatTickX}\n        dataset={data}\n      />\n    </Html>\n  </LayerCake>\n</div>"},"dek":"A multiline example with a quadtree tooltip.\n","components":[{"title":"./components/MultiLine.svelte","contents":"<script>\n  /**\n    Generates an SVG multi-series line chart. It expects your data to be an array of objects, each with a `values` key that is an array of data objects.\n  */\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, zGet } = getContext('LayerCake');\n\n  $: path = values => {\n    return 'M' + values\n      .map(d => {\n        return $xGet(d) + ',' + $yGet(d);\n      })\n      .join('L');\n  };\n</script>\n\n<g class=\"line-group\">\n  {#each $data as group}\n    <path\n      class='path-line'\n      d='{path(group.values)}'\n      stroke=\"{$zGet(group)}\"\n    ></path>\n  {/each}\n</g>\n\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 3px;\n  }\n</style>"},{"title":"./components/AxisX.svelte","contents":"<script>\n  /**\n    Generates an SVG x-axis. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n    @type {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space\n    @type {Boolean} [tickMarks=false] – Show a vertical mark for each tick.\n    @type {Boolean} [baseline=false] – Show a solid line at the bottom.\n    @type {Boolean} [snapTicks=false] – Instead of centering the text on the first and the last items, align them to the edges of the chart.\n    @type {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return.\n    @type {Number|Array|Function} [ticks] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function.\n    @type {Number} [xTick=0] – TK\n    @type {Number} [yTick=16] – The distance from the baseline to place each tick value.\n  */\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yRange } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let tickMarks = false;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let formatTick = d => d;\n  export let ticks = undefined;\n  export let xTick = 0;\n  export let yTick = 16;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class='axis x-axis' class:snapTicks>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{ i }' transform='translate({$xScale(tick)},{$yRange[0]})'>\n      {#if gridlines !== false}\n        <line class=\"gridline\" y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      {#if tickMarks === true}\n        <line class=\"tick-mark\" y1='{0}' y2='{6}' x1='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}' x2='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}'></line>\n      {/if}\n      <text\n        x=\"{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}\"\n        y='{yTick}'\n        dx=''\n        dy=''\n        text-anchor='{textAnchor(i)}'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick .tick-mark,\n  .baseline {\n    stroke-dasharray: 0;\n  }\n  /* This looks slightly better */\n  .axis.snapTicks .tick:last-child text {\n    transform: translateX(3px);\n  }\n  .axis.snapTicks .tick.tick-0 text {\n    transform: translateX(-3px);\n  }\n</style>"},{"title":"./components/AxisY.svelte","contents":"<script>\n  /**\n    Generates an HTML y-axis.\n    @type {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space\n    @type {Boolean} [tickMarks=false] – Show a vertical mark for each tick.\n    @type {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return.\n    @type {Number|Array|Function} [ticks=4] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return.\n    @type {Number} [xTick=0] – How far over to position the text marker.\n    @type {Number} [dxTick=0] – Any optional value passed to the `dx` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal.\n    @type {Number} [yTick=0] – How far up and down to position the text marker.\n    @type {Number} [dyTick=0] – Any optional value passed to the `dy` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal.\n  */\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, yScale } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let tickMarks = false;\n  export let formatTick = d => d;\n  export let ticks = 4;\n  export let xTick = 0;\n  export let yTick = 0;\n  export let dxTick = 0;\n  export let dyTick = -4;\n  export let textAnchor = 'start';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<g class='axis y-axis' transform='translate({-$padding.left}, 0)'>\n  {#each tickVals as tick}\n    <g class='tick tick-{tick}' transform='translate({$xRange[0] + (isBandwidth ? $padding.left : 0)}, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line\n          class=\"gridline\"\n          x2='100%'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      {#if tickMarks === true}\n        <line\n          class='tick-mark'\n          x1='0'\n          x2='{isBandwidth ? -6 : 6}'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      <text\n        x='{xTick}'\n        y='{yTick + (isBandwidth ? $yScale.bandwidth() / 2 : 0)}'\n        dx='{isBandwidth ? -9 : dxTick}'\n        dy='{isBandwidth ? 4 : dyTick}'\n        style=\"text-anchor:{isBandwidth ? 'end' : textAnchor};\"\n      >{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n  }\n  .tick .gridline {\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/GroupLabels.html.svelte","contents":"<script>\n  /**\n    Generates HTML text labels for a nested data structure. It places the label near the y-value of the highest x-valued data point. This is useful for labeling the final point in a multi-series line chart, for example. It expects your data to be an array of objects where each has a `key` field that is the label to display and a `values` field that is an array of data objects.\n  */\n  import { getContext } from 'svelte';\n  import { max } from 'd3-array';\n\n  const { data, x, y, xScale, yScale, xRange, yRange } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Title case the first letter\n   */\n  const cap = val => val.replace(/^\\w/, d => d.toUpperCase());\n\n  /* --------------------------------------------\n   * Put the label on the highest value\n   */\n  $: left = values => $xScale(max(values, $x)) /  Math.max(...$xRange);\n  $: top = values => $yScale(max(values, $y)) / Math.max(...$yRange);\n</script>\n\n{#each $data as group}\n  <div\n    class=\"label\"\n    style=\"\n      top:{top(group.values) * 100}%;\n      left:{left(group.values) * 100}%;\n    \"\n  >{cap(group.key)}</div>\n{/each}\n\n<style>\n  .label {\n    position: absolute;\n    transform: translate(-100%, -100%)translateY(1px);\n    font-size: 13px;\n  }\n</style>"},{"title":"./components/SharedTooltip.html.svelte","contents":"<script>\n  /**\n    Generates a tooltip that works on multiseries datasets, like multiline charts. It creates a tooltip showing the name of the series and the current value. It finds the nearest data point using the [QuadTree.html.svelte](https://layercake.graphics/components/QuadTree.html.svelte) component.\n    @type {Function} [formatTitle=d => d] – A function to format the tooltip title, which is `$config.x`.\n    @type {Function} [formatKey=d => titleCase(d)] – A function to format the series name.\n    @type {Function} [formatValue=d => isNaN(+d) ? d : commas(d)] – A function to format the value.\n    @type {Array} [dataset=$data] – The dataset to work off of. You can pass something custom in here in case you don't want to use the main data or it's in a strange format.\n    @type {Number} [offset=20] – A negative y-offset from the hover point, in pixels.\n    */\n  import { getContext } from 'svelte';\n  import { format } from 'd3-format';\n\n  import QuadTree from './QuadTree.html.svelte';\n\n  const { data, width, yScale, config } = getContext('LayerCake');\n\n  const commas = format(',');\n  const titleCase = d => d.replace(/^\\w/, w => w.toUpperCase());\n\n  export let offset = 20;\n  export let dataset = $data;\n  export let formatTitle = d => d;\n  export let formatKey = d => titleCase(d);\n  export let formatValue = d => isNaN(+d) ? d : commas(d);\n\n  const w = 150;\n  const w2 = w / 2;\n\n  /* --------------------------------------------\n   * Sort the keys by the highest value\n   */\n  function sortResult(result) {\n    if (Object.keys(result).length === 0) return [];\n    const rows = Object.keys(result).filter(d => d !== $config.x).map(key => {\n      return {\n        key,\n        value: result[key]\n      };\n    }).sort((a, b) => b.value - a.value);\n\n    return rows;\n  }\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    font-size: 13px;\n    pointer-events: none;\n    border: 1px solid #ccc;\n    background: rgba(255, 255, 255, 0.85);\n    transform: translate(-50%, -100%);\n    padding: 5px;\n    z-index: 15;\n    pointer-events: none;\n  }\n  .line {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    border-left: 1px dotted #666;\n    pointer-events: none;\n  }\n  .tooltip,\n  .line {\n    transition: left 250ms ease-out, top 250ms ease-out;\n  }\n  .title {\n    font-weight: bold;\n  }\n  .key {\n    color: #999;\n  }\n</style>\n\n<QuadTree\n  dataset={dataset}\n  y='x'\n  let:x\n  let:y\n  let:visible\n  let:found\n  let:e\n>\n  {#if visible === true}\n    <div\n      style=\"left:{x}px;\"\n      class=\"line\"></div>\n    <div\n      class=\"tooltip\"\n      style=\"\n        width:{w}px;\n        display: { visible ? 'block' : 'none' };\n        top:{$yScale(sortResult(found)[0].value) - offset}px;\n        left:{Math.min(Math.max(w2, x), $width - w2)}px;\"\n      >\n        <div class=\"title\">{formatTitle(found[$config.x])}</div>\n        {#each sortResult(found) as row}\n          <div class=\"row\"><span class=\"key\">{formatKey(row.key)}:</span> {formatValue(row.value)}</div>\n        {/each}\n    </div>\n  {/if}\n</QuadTree>"}],"modules":[],"componentModules":[],"componentComponents":[{"title":"./components/QuadTree.html.svelte","contents":"<script>\n  /**\n    Creates an interaction layer (in HTML) using [d3-quadtree](https://github.com/d3/d3-quadtree) to find the nearest datapoint to the mouse. This component creates a slot that exposes variables `x`, `y`, `found` (the found datapoint), `visible` (a Boolean whether any data was found) and `e` (the event object).\n\n    The quadtree searches across both the x and y dimensions at the same time. But if you want to only search across one, set the `x` and `y` props to the same value. For example, the [shared tooltip component](https://layercake.graphics/components/SharedTooltip.html.svelte) sets `y='x'` since it's nicer behavior to only pick up on the nearest x-value.\n    @type {String} [searchRadius=undefined] – The number of pixels to search around the mouse's location. This is the third argument passed to [`quadtree.find`](https://github.com/d3/d3-quadtree#quadtree_find) and by default a value of `undefined` means an unlimited range.\n    @type {String} [x='x'] – The dimension to search across when moving the mouse left and right.\n    @type {String} [y='y'] – The dimension to search across when moving the mouse up and down.\n    @type {Array} [dataset=$data] – The dataset to work off of. You can pass something custom in here in case you don't want to use the main data or it's in a strange format.\n  */\n  import { getContext } from 'svelte';\n  import { quadtree } from 'd3-quadtree';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  let visible = false;\n  let found = {};\n  let e = {};\n\n  export let dataset = undefined;\n  export let x = 'x';\n  export let y = 'y';\n  export let searchRadius = undefined;\n\n  $: xGetter = x === 'x' ? $xGet : $yGet;\n  $: yGetter = y === 'y' ? $yGet : $xGet;\n\n  function findItem (evt) {\n    e = evt;\n\n    const xLayerKey = `layer${x.toUpperCase()}`;\n    const yLayerKey = `layer${y.toUpperCase()}`;\n\n    console.log('evt', evt[xLayerKey], evt[yLayerKey]);\n\n    found = finder.find(evt[xLayerKey], evt[yLayerKey], searchRadius) || {};\n    visible = Object.keys(found).length > 0;\n  }\n\n  $: finder = quadtree()\n    .extent([[-1, -1], [$width + 1, $height + 1]])\n    .x(xGetter)\n    .y(yGetter)\n    .addAll(dataset || $data);\n</script>\n\n<style>\n  .bg {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n</style>\n\n<div\n  class=\"bg\"\n  on:mousemove=\"{findItem}\"\n  on:mouseout=\"{() => visible = false}\"\n  on:blur=\"{() => visible = false}\"\n></div>\n<slot\n  x={xGetter(found) || 0}\n  y={yGetter(found) || 0}\n  {found}\n  {visible}\n  {e}\n></slot>"}],"csvs":[{"title":"./data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}],"jsons":[]}